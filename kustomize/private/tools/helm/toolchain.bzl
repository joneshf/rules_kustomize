# We must accommodate loading this file from repositories generated by
# our repository rules.
visibility("public")

_TOOLS_BY_RELEASE = {
    "v3.13.1": {
        struct(os = "darwin", arch = "amd64"): "e207e009b931162b0383b463c333a2792355200e91dbcf167c97c150e9f5fedb",
        struct(os = "darwin", arch = "arm64"): "46596d6d2d9aa545eb74f40684858fac0841df373ca760af1259d3493161d8c9",
        struct(os = "linux", arch = "amd64"): "98c363564d00afd0cc3088e8f830f2a0eeb5f28755b3d8c48df89866374a1ed0",
        struct(os = "linux", arch = "arm64"): "8c4a0777218b266a7b977394aaf0e9cef30ed2df6e742d683e523d75508d6efe",
        struct(os = "windows", arch = "amd64"): "6e16fbc5e50a5841be2dc725e790234f09aa2a5ebe289493c90f65ecae7b156f",
        # NB: There is no Windows build available for the ARM64 architecture.
    },
    "v3.12.1": {
        struct(os = "darwin", arch = "amd64"): "f487b5d8132bd2091378258a3029e33ee10f71575b2167cdfeaf6d0144d20938",
        struct(os = "darwin", arch = "arm64"): "e82e0433589b1b5170807d6fec75baedba40620458510bbd30cdb9d2246415fe",
        struct(os = "linux", arch = "amd64"): "1a7074f58ef7190f74ce6db5db0b70e355a655e2013c4d5db2317e63fa9e3dea",
        struct(os = "linux", arch = "arm64"): "50548d4fedef9d8d01d1ed5a2dd5c849271d1017127417dc4c7ef6777ae68f7e",
        struct(os = "windows", arch = "amd64"): "9040f8f37c90600a51db4934c04bc9c2adc058cb2161e20b5193b3ba46de10fa",
        # NB: There is no Windows build available for the ARM64 architecture.
    },
    "v3.11.3": {
        struct(os = "darwin", arch = "amd64"): "9d029df37664b50e427442a600e4e065fa75fd74dac996c831ac68359654b2c4",
        struct(os = "darwin", arch = "arm64"): "267e4d50b68e8854b9cc44517da9ab2f47dec39787fed9f7eba42080d61ac7f8",
        struct(os = "linux", arch = "amd64"): "ca2d5d40d4cdfb9a3a6205dd803b5bc8def00bd2f13e5526c127e9b667974a89",
        struct(os = "linux", arch = "arm64"): "9f58e707dcbe9a3b7885c4e24ef57edfb9794490d72705b33a93fa1f3572cce4",
        struct(os = "windows", arch = "amd64"): "ae146d2a90600c6958bc801213daef467237cf475e26ab3f476dfb8e0d9549b7",
        # NB: There is no Windows build available for the ARM64 architecture.
    },
    "v3.11.2": {
        struct(os = "darwin", arch = "amd64"): "404938fd2c6eff9e0dab830b0db943fca9e1572cd3d7ee40904705760faa390f",
        struct(os = "darwin", arch = "arm64"): "f61a3aa55827de2d8c64a2063fd744b618b443ed063871b79f52069e90813151",
        struct(os = "linux", arch = "amd64"): "781d826daec584f9d50a01f0f7dadfd25a3312217a14aa2fbb85107b014ac8ca",
        struct(os = "linux", arch = "arm64"): "0a60baac83c3106017666864e664f52a4e16fbd578ac009f9a85456a9241c5db",
        struct(os = "windows", arch = "amd64"): "bca0c5b99a0e6621032f1767e61a1723b86c5f4ef565fa58be8be6d619a4276a",
        # NB: There is no Windows build available for the ARM64 architecture.
    },
    "v3.11.0": {
        struct(os = "darwin", arch = "amd64"): "5a3d13545a302eb2623236353ccd3eaa01150c869f4d7f7a635073847fd7d932",
        struct(os = "darwin", arch = "arm64"): "57d36ff801ce8c0201ce9917c5a2d3b4da33e5d4ea154320962c7d6fb13e1f2c",
        struct(os = "linux", arch = "amd64"): "6c3440d829a56071a4386dd3ce6254eab113bc9b1fe924a6ee99f7ff869b9e0b",
        struct(os = "linux", arch = "arm64"): "57d36ff801ce8c0201ce9917c5a2d3b4da33e5d4ea154320962c7d6fb13e1f2c",
        struct(os = "windows", arch = "amd64"): "55477fa4295fb3043835397a19e99a138bb4859fbe7cd2d099de28df9d8786f1",
        # NB: There is no Windows build available for the ARM64 architecture.
    },
}

_DEFAULT_TOOL_VERSION = "v3.13.1"

def known_release_versions():
    return _TOOLS_BY_RELEASE.keys()

HelmInfo = provider(
    doc = "Details pertaining to the Helm toolchain.",
    fields = {
        "tool": "Helm tool to invoke",
        "version": "This tool's released version name",
    },
)

HelmToolInfo = provider(
    doc = "Details pertaining to the Helm tool.",
    fields = {
        "binary": "Helm tool to invoke",
        "version": "This tool's released version name",
    },
)

def _helm_tool_impl(ctx):
    return [HelmToolInfo(
        binary = ctx.executable.binary,
        version = ctx.attr.version,
    )]

helm_tool = rule(
    implementation = _helm_tool_impl,
    attrs = {
        "binary": attr.label(
            mandatory = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec",
            doc = "Helm tool to invoke",
        ),
        "version": attr.string(
            mandatory = True,
            doc = "This tool's released version name",
        ),
    },
)

def _toolchain_impl(ctx):
    tool = ctx.attr.tool[HelmToolInfo]
    toolchain_info = platform_common.ToolchainInfo(
        helminfo = HelmInfo(
            tool = tool.binary,
            version = tool.version,
        ),
    )
    return [toolchain_info]

helm_toolchain = rule(
    implementation = _toolchain_impl,
    attrs = {
        "tool": attr.label(
            mandatory = True,
            providers = [HelmToolInfo],
            cfg = "exec",
            doc = "Helm tool to use for inflating Helm charts.",
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_helm_toolchains(helm_tool):
    for version, platforms in _TOOLS_BY_RELEASE.items():
        for platform in platforms.keys():
            helm_toolchain(
                name = "{}_{}_{}".format(platform.os, platform.arch, version),
                tool = helm_tool,
            )

def _translate_host_platform(ctx):
    # NB: This is adapted from rules_go's "_detect_host_platform" function.
    os = ctx.os.name
    if os == "mac os x":
        os = "darwin"
    elif os.startswith("windows"):
        os = "windows"

    arch = ctx.os.arch
    if arch == "aarch64":
        arch = "arm64"
    elif arch == "x86_64":
        arch = "amd64"

    return os, arch

_MODULE_REPOSITORY_NAME = "rules_kustomize"
_CONTAINING_PACKAGE_PREFIX = "//kustomize/private/tools/helm"

def _download_tool_impl(ctx):
    if not ctx.attr.arch and not ctx.attr.os:
        os, arch = _translate_host_platform(ctx)
    else:
        if not ctx.attr.arch:
            fail('"os" is set but "arch" is not')
        if not ctx.attr.os:
            fail('"arch" is set but "os" is not')
        os, arch = ctx.attr.os, ctx.attr.arch
    version = ctx.attr.version

    sha256sum = _TOOLS_BY_RELEASE[version][struct(os = os, arch = arch)]
    if not sha256sum:
        fail('No Helm tool is available for OS "{}" and CPU architecture "{}" at version {}'.format(os, arch, version))
    ctx.report_progress('Downloading Helm tool for OS "{}" and CPU architecture "{}" at version {}.'.format(os, arch, version))
    ctx.download_and_extract(
        url = "https://get.helm.sh/helm-{}-{}-{}.{}".format(
            version,
            os,
            arch,
            "zip" if os == "windows" else "tar.gz",
        ),
        stripPrefix = "{}-{}".format(os, arch),
        sha256 = sha256sum,
    )

    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.tool.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{extension}": ".exe" if os == "windows" else "",
            "{version}": version,
        },
    )
    return None

_download_tool = repository_rule(
    implementation = _download_tool_impl,
    attrs = {
        "arch": attr.string(),
        "os": attr.string(),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_bazel_toolchains(version, toolchain_prefix):
    native.constraint_value(
        name = version,
        constraint_setting = "{}:tool_version".format(_CONTAINING_PACKAGE_PREFIX),
    )
    constraint_value_prefix = "@{}//kustomize/private/tools".format(_MODULE_REPOSITORY_NAME)
    for platform in _TOOLS_BY_RELEASE[version].keys():
        native.toolchain(
            name = "{}_{}_{}_toolchain".format(platform.os, platform.arch, version),
            exec_compatible_with = [
                "{}:cpu_{}".format(constraint_value_prefix, platform.arch),
                "{}:os_{}".format(constraint_value_prefix, platform.os),
            ],
            toolchain = toolchain_prefix + (":{}_{}_{}".format(platform.os, platform.arch, version)),
            toolchain_type = "@{}//tools/helm:toolchain_type".format(_MODULE_REPOSITORY_NAME),
        )

def _toolchains_impl(ctx):
    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.toolchains.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{tool_repo}": ctx.attr.tool_repo,
            "{version}": ctx.attr.version,
        },
    )

_toolchains_repo = repository_rule(
    implementation = _toolchains_impl,
    attrs = {
        "tool_repo": attr.string(mandatory = True),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

def download_tool(name, version = None):
    _download_tool(
        name = name,
        version = version,
    )
    _toolchains_repo(
        name = name + "_toolchains",
        tool_repo = name,
        version = version,
    )
